# 스프링 핵심 원리 이해 2 - 객체 지향의 원리

### 새로운 할인 정책 개발
* 정액 할인 ➡️ 정률 할인으로 변경


### 새로운 할인 정책 적용과 문제점
* 클래스 의존관계 분석
* OrderServiceImple
  * 추상(인터페이스) 의존 : DiscountPolicy
  * 구현 클래스 : FixDiscount, RateDiscount
```java
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final DiscountPolicy discountPolicy = new FixDiscountPolicy(); // *

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice); // 단일 책임 원칙

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```
* ⚠️DIP 위반 - 클라이언트인 `OrderServiceImpl`이 `DiscountPolicy` 인터페이스 뿐만 아니라 `FixDiscountPolicy`인 구현 클래스도 함께 의존하고 있다. 

* 추상에만 의존해야한다!!!!!
*  ⚠️OCP 위반 - `FixDiscountPolicy`를 `RateDiscountPolicy`로 변경하는 순간 `OrderServiceImpl`의 소스 코드도 함께 변경해야 한다.

**해결 방법**
* DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경하면 된다. 
```java
    private final DiscountPolicy discountPolicy;
```

### 관심사의 분리
* 애플리케이션 - 공연
* 인터페이스 - 로미오 역
* 배우 - 구현체  

> 관심사를 분리하자
* 배우는 본인의 역할인 배역 연기만 집중
* 배우는 상대역이 누구인지 상관없이 똑같이 공연할 수 있다. 
* 공연기획자 - 공연 구성, 배우 섭외, 배우 지정
* 공연기획자와 배우의 역할을 구분

**AppConfig**
* 애플리케이션의 실제 동작에 필요한 **구현 객체를 생성**한다.
* 생성한 객체 인스턴스의 참조(레퍼런스)를 **생성자를 통해서 주입(연결)**해준다.
  * MemberService ➡️ MemoryMemberRepository
```java
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }
}
```
```java
public class MemberServiceImpl implements MemberService {
    private final MemberRepository memberRepository;
    
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    //...
}
```
* MemberService는 더이상 MemoryMemberRepository를 의존하지 않는다.
* MemoryRepository 인터페이스에만 의존한다. 
* 어떤 구현 객체를 주입할지는 AppConfig에서 결정된다. - 객체의 생성과 연결 
* 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중한다.